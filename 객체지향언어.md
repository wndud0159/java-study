# 객체지향 언어
- 코드의 재사용성이 높다.
  - 새로운 코드를 작성할 때 기존의 코드를 이용하여 쉽게 작성할 수 있다
- 코드의 관리가 용이하다.
  - 코드간의 관계를 이용해서 적은 노력으로 쉽게 코드를 변경할 수 있다
- 신뢰성이 높은 프로그래밍을 가능하게 한다.
  - 제어자와 메서드를 이용해서 데이터를 보호하고 올바른 값을 유지하도록 하며, 코드의 중복을 제거하여 코드의 불일치로 인한 오동작을 방지할 수 있다.
---
---
## 클래스와 객체
- 클래스의 정의
  - 클래스란 객체를 정의해 놓은 것이다.
- 클래스의 용도
  - 클래스는 객체를 생성하는데 사용한다.
- 객체의 정의
  - 실제로 존재하는것. 사물 또는 개념
- 객체의 용도
  - 객체가 가지고 있는 속성과 기능에 따라 다름
- 유형의 객체
  - 책상, 의자, 자동차, TV와 같은 사물
- 무형의 객체
  - 수학공식, 프로그램 에러와 같은 논리나 개념
---
---
## 객체와 인스턴스
- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화(instantiate)라고 하며, 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스(instance)라고 한다
---
---
## 객체의 구성요소
- 객체는 속성과 기능, 두 종류의 구성요소로 이루어져 있으며, 일반적으로 객체는 다수의 속성과 다수의 기능을 갖는다
- 객체는 속성과 기능의 집합
- 객체가 가지고 있는 속성과 기능을 그 객체의 멤버(구성원, member)라 한다
```
속성(property)
  - 맴버변수(meber variable)
  - 특성(attribute)
  - 필드(field)
  - 상태(state)
기능(function)
  - 메서드(method)
  - 함수(function)
  - 행위(behavior)
```
---
---
## 인스턴스의 생성과 사용
```java
클래스명 변수명; // 클래스의 객체를 참조하기 위한 참조변수를 선언
변수명 = new 클래스명(); // 클래스의 객체를 생성 후, 객체의 주소를 참조변수에 저장


Tv tv; // Tv클래스 타입의 참조변수 tv를 선언
tv = new Tv(); // Tv인스턴스를 생성한 후, 생성된 Tv인스턴스의 주소를 t에 저장
```
- 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야 한다.
---
---
## 객체 배열
객체 배열 == 참조변수 배열
```
Tv tv1, tv2, tv3  >>> tv[] tvArr = new Tv[3]
```


>메모리주소() <br>
>// 길이가 3인 Tv타입의 참조변수 <br>
>tv[] tvArr = new Tv[3]; 배열<br>
>tvArr(0x100)<br>
>//객체를 생성해서 배열의 각 요소에 저장<br>
>tvArr[0] = new Tv();<br>
>tvArr[1] = new Tv();<br>
>tvArr[2] = new Tv();<br>
> tvArr[0] (0x200), tvArr[1] (0x300), tvArr[2] (0x400)
---
---
## 클래스의 또 다른 정의
### `클래스란`

1. 설계도
2. 데이터 + 함수
3. 사용자 정의 타입

```
변수
- 하나의 데이터를 저장할 수 있는 공간
배열
- 같은 종류의 여러 데이터를 하나로 저장할 수 있는 공간
구조체
- 서로 관련된 여러 데이터(종류관계x)를 하나로 저장할 수 있는 공간
클래스
- 데이터와 함수의 결합(구조체 + 함수)
```
### `사용자 정의 타입 - 원하는 타입을 직접 만들 수 있다`

- 비객체지향적인 코드
```java
int hour;
int minute;
int second;
```
- 객체지향적인 코드
```java
class Time {
    int hour = 12;
    int minute = 34;
    int second = 45;
}
Time t = new Time();
t.hour = 12;
t.minute = 34;
t.second = 56;
```
---
---
## 선언 위치에 따른 변수의 종류
```java
class Variables{ // 클래스영역
    int instanceVariable; // 인스턴스변수
    static int classVariable; // 클래스변수(static변수, 공유변수)

    void method(){ // 메서드 영역
        int localVariable = 0; // 지역변수
    }
}
```
변수의 종류 | 선언 위치 | 생서시기
:---:|:---:|:---:
클래스 변수 | 클래스 영역 | 클래스가 메모리에 올라갈 때
인스턴스 변수 | 클래스 영역 | 인스턴스가 생성되었을 때
지역 변수 | 클래스 영역 이외의 영역 | 변수 선언문이 수행되었을 때

## 클래스 변수와 인스턴스 변수
```java
// 포커카드의 예시
// 포커카드의 카드들은 숫자와 무늬는 개별적이다 = instanceVariable
// 포커카드의 카드들은 폭과 높이는 공통적이다 = classVariable
class Card {
    //개별속성
    String kind; // 무늬
    int number; //숫자

    //공통속성
    static int width = 100; // 폭
    static int height = 250; // 높이
} 
```
---
---
## 메서드란
1. 문장들을 묶은 것
2. 값(입력)을 받아서 처리하고, 결과를 반환(출력)
3. 반복적으로 수행되는 여러 문장을 메서드로 작성
4. 하나의 메서드는 한 가지 기능만 수행하도록 작성
5. > 메서드 = 함수 (자바에선 객체지향개념에서 함수를 지칭하는 용어)
    > 차이점<br>
    > 메서드는 클래스 안에 선언되어야함<br>
    > 함수는 그런 제약이 없다

```java
//반환타입(출력), 메서드이름, 매개변수선언(입력)
int add(int x, int y) // 메서드 선언부 
{ // 메서드 구현부
    int result = x + y;

    return result; // 결과를 반환
}
```
## 메서드의 장점
- 코드의 중복을 줄일 수 있다.
- 코드의 관리가 쉽다.
- 코드를 재사용할 수 있다.
- 코드가 간결해서 이해하기 쉬워진다.
---
---
## JVM의 메모리 구조
- 메서드영역(method area)
  - 프로그램 실행 중 어떤 클래스가 사용되면, JVM은 해당 클래스의 클래스파일(*.class)을 읽어서 분석하여 클래스에 대한 정보를 이곳에 저장한다. 이 때, 그 클래스의 클래스변수(classVariable)도 이 영역에 생성된다.
- 힙(heep)
  - 인스턴스가 생성되는 공간. 프로그램 실행 중 생성되는 인스턴스는 모두 이곳에 생성된다 즉, 인스턴스변수(instanceVariable)들이 생성되는 공간이다
- 호출스택(call stack 또는 execution stack)
  - 호출스택은 메서드의 작업에 필요한 메모리 공간을 제공한다. 메서드가 호출되면, 호출스택에 호출된 메서드를 위한 메모리가 할당되며, 이 메모리는 메서드가 작업을 수행하는 동안 지역변수(매개변수 포함)들과 연산의 중간결과 등을 저장하는데 사용된다. 그리고 메서드가 작업을 마치면 할당되었던 메모리공간은 반환되어 지워진다.
    ```java
    class callStack {
      public static void main(Stringp[] args) {
        System.out.println("Hello"); // main() 먼저 스택에 쌓이고 println()을 실행하면 main()위에 println()스택이 쌓이고 main()는 중지 되면서 println()이 실행된다음 실행이 끝나면 사라지고 main()이 실행된다
      }
    }
    ```
---
---
## 매개변수
- `기본형 매개변수 - 변수의 값을 읽기만 할 수 있다(read only)`
```java
class Data { int x;}

class primitiveTypeParameter {
    public static void main(String[] args) {
        Data d = new Data(); // 객체 생성
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d.x);
        System.out.println("After change(d.x)") //스택상황
        System.out.println("main() : x = " + d.x);
    }
    static void change(int x) { // 기본형 매개변수
        x = 1000;
        System.out.println("change() : x = " + x);
    }
}
```
- `참조형 매개변수 - 변수의 값을 읽고 변경할 수 있다.(read & write)`
```java
class Data { int x;}

class referenceTypeParameter {
    public static void main(String[] args) {
        Data d = new Data(); // 객체 생성
        d.x = 10;
        System.out.println("main() : x = " + d.x);

        change(d);
        System.out.println("After change(d)") //스택상황
        System.out.println("main() : x = " + d.x);
    }
    static void change(data d) { // 참조형 매개변수
        d.x = 1000;
        System.out.println("change() : x = " + d.x);
    }
}
```
---
---
## 재귀호출(recursive call)
- 메서드의 내부에서 메서드 자신을 다시 호출하는것을 재귀호출이라 하고, 재귀호출을 하는 메서드를 재귀 메서드라 한다.
```java
void recursiveMethod(int n) {
  if(n == 0)
    return; // n의 값이 0일때, 메서드를 종료한다.
  
  System.out.println(n);

  recursiveMethod(--n); // 재귀호출
}
```
---
---
## static메서드와 instance메서드
>인스턴스 메서드<br>
-인스턴스 생성 후, 참조변수.메서드이름() 으로 호출<br>
-인스턴스 멤버(iv, im)와 관련된 작업을 하는 메서드<br>
-메서드 내에서 인스턴스 변수(iv) 사용가능

>스태틱메서드(클래스메서드)<br>
-객체생성 없이 클래스이름.메서드이름()으로 호출<br>
-인스턴스 멤버(iv,im)와 관련없는 작업을 하는 메서드<br>
-메서드 내에서 인스턴스 변수(iv) 사용불가
## 메서드 간의 호출과 참조
```java
class TestClass {
    int instanceVariable; // 인스턴스 변수
    static int classVariable;

    void intanceMethod() { // 인스턴스 메서드
        System.out.println(instanceVariable); // 인스턴스변수 사용가능
        System.out.println(ClassVariable); // 클래스변수 사용 가능
    }
    
    void staticMethod() { // 스태틱 메서드
        System.out.println(intanceVariable); // !!인스턴스변수 사용불가xxxxxxxx
        System.out.println(classVariable); // 클래스변수 사용 가능
    }

    // 차이 인스턴스변수를 사용하는가 안하는가의 차이가 있다
    /* 
    왜 스태틱 메서드는 인스턴스 변수를 사용 못하는가
    - 스태틱이 붙은 것들은 class 파일이 메모리에 올라갈 때 생성되기 때문에 인스턴스 변수를 읽을 수 없다? 맞나? 맞는거 같은데
    */
}
```
- 클래스를 설계할 때, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
  - 생성된 각 인스턴스는 서로 독립적이기 때문에 각 인스턴스의 변수(instanceVaiable)는 서로 다른 값을 유지한다. 그러나 모든 인스턴스에서 같은 값이 유지되어야 하는 변수는 static을 붙여서 클래스변수로 정의 해야한다.
- 클래스변수(static변수)는 인스턴스를 생성하지 않아도 사용할 수 있다.
  - static이 붙은 변수는 클래스가 메모리에 올라갈 때 이미 자동적으로 생성되기 때문이다.
- 클래스메서드(static메서드)는 인스턴스 변수를 사용할 수 없다.
  - 인스턴스변수는 인스턴스가 반드시 존재해야한 사용할 수 있는데, 클래스메서드는 인스턴스 생성 없이 호출가능하므로 클래스 메서드가 호출되었을 때 인스턴스가 존재하지 않을 수도 있다. 그래서 클래스 메서드에서 인스턴스 변수의 사용을 금지한다. 반면에 인스턴스 변수나 인스턴스메서드는 static이 붙은 멤버들을 사용하는 것이 언제나 가능하다. 인스턴스 변수가 존재한다는 것은 static변수가 이미 메모리에 존재한다는 것을 의미하기 때문이다.
- 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.
  - 메서드의 작업내용 중에서 인스턴스 변수를 필요로 한다면, static을 붙일 수 없다. 반대로 인스턴스변수를 필욜호 하지 않는다면 static을 붙이자 메서드 호출시간이 짧아지므로 성능이 향상된다.
---
---
## 오버로딩(overloading)
- 한 클래스 안에 같은 이름의 메서드 여러 개 정의하는것
```java
void println()
void println(boolean x)
void println(char x)
void println(char[] x)
void println(double x)
void println(float x)
void println(int x)
void println(long x)
void println(Object x)
void println(String x)
```
- 오버로딩이 성립하기 위한 조건
1. 메서드 이름이 같아야 한다.
2. 매개변수 개수 또는 타입이 달라야 한다.
3. 반환타입은 영향 없다.

`오버로딩 잘못된 사용법`
```java
int add(int a, int b) { return a+b; }
int add(int x, int y) { return x+y; }
// 메소드 중복 정의 에러남 매개변수의 개수가 같고 타입도 같기 때문?
long add(int a, int b) { return (long)a+b; }
int add(int a, int b) { return a+b; }
// 반환타입은 영향이 없기 때문에 에러
long add(long a, int b) { return a+b; }
long add(int a, long b) { return a+b; }
//오버로딩 성립 메소드명 같다, 매개변수 타입이 다르다.
/*
하지만 이 경우에 조심해야 하는것 호출시
add(3,3) 경우 둘다 반응을 함... 컴파일러가 둘 중 어느것을 사용해야할지 알 수 없음
add(3L,3)/ 이런식으로 사용 
*/

```
`오버로딩 올바른 사용법`
```java
int add(int a, int b) { return a+b; }

long add(long a, long b) { return a+b; }

int add(int[] a) {
     int result = 0;
     for(int i = 1; i < a.length; i++) {
         result += a[i]
     }
     return result;
}
```
### `c++ 에선 연산자 오버로딩이 있지만 자바에선 제공은 하지 않지만 있기는함`
- 예)
    - 플러스(+)
      - 부호(+5)
      - 덧셈(3+5)
      - 문자열 결합("Hel"+"lo")
## 가변인자와(varargs)와 오버로딩
- 기존에는 메서드의 매개변수 개수가 고정적이었으나 jdk1.5부터 동적으로 지정해 줄 수 있게 되었으며, 이 기능을 가변인자(variable arguments)라고 한다
- 가변인자는 `타입... 변수명`과 같은 형식으로 선언하며, printStream클래스의 printf()가 대표적인 예이다.
```java
public printStream printf(String format, Object... args){...}
//위와 같이 가변인자 외에도 매개변수가 더 있다며느 가변인자를 매개변수 중에서 제일 마지막에 선언해야 한다. 그렇지 않으면, 컴파일 에러가 발생한다. 가변인자인지 아닌지를 구별할 방법이 없기 때문

// Ex Code
class VariableArguments {
  public static void maint(String[] args) {
    String[] strArr = { "100", "200", "300" };

    System.out.println(concatenate("", strArr));
    // 100200300
    System.out.println(concatenate("-", strArr));
    // 100-200-300-
    System.out.println(concatenate(",", new String[]{"100","200","300"}));
    // 100,200,300,

  }

  static String concatenate(String delim, String... args) {
    String result = "";

    for(String str : args) {
      result += str + delim;
    }

    return result;
  }

  static String concatenate(String... args) {
    return concatenate("", args);
  }
}
```
---
---
## 생성자
- 생성자는 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드`이다. 따라서 인스턴스변수의 초기화 작업에 주로 사용되며, 인스턴스 생성 시에 실행되어야 할 작업을 위해서도 사용된다.
- 생성자의 이름은 클래스의 이름과 같아야 한다.
- 생성자는 리턴 값이 없다.
- 연산자 new가 인스턴스를 생성하는 것이지 생성자가 인스턴스를 생성하는 것이 아니다.
## 생성자 this()
- 생성자에서 다른 생성자 호출할 때 사용
- 다른 생성자 호출시 첫 줄에서만 사용가능
- 생성자는 instanceVariable 을 초기화를 하는일을 한다
```java
class Car {
    String color; // 색상
    String gearType; // 변속기 종류 - auto(자동), manual(수동)
    int door; // 문의 개수

    Car() {
        this("white", "auto", 4);
    }

    Car(String color) {
        this(color, "auto", 4);
    }

    Car(String color, String gearType, int door) {
        this.color = color;
        this.gearType = gearType;
        this.door = door;
    }
}
```
## 참조변수 this
- 인스턴스 자신을 가리키는 참조변수
- 인스턴스 메서드(생성자 포함) 에서 사용가능
- 지역변수(localVariable)와 인스턴스변수(instanceVariable)를 구별할때 사용
---
---
## 변수의 초기화
- 지역변수(localVariable)는 수동초기화 해야함(사용전 꼭!)
- 맴버변수(iv, cv)는 자동 초기화 된다
```java
// 자동 초기화
class Init { 
    int x; // 인스턴스 변수
    int y = x; // 인스턴스 변수

    void method() {
        int i; //지역변수
        int j = i; // 에러 지역변수를 초기화하지 않고 사용
    }
}
```
## 멤버변수의 초기화
1. 명시적 초기화(=)
```java
// 간단 초기화
class Car { 
    int door = 4; // 기본형(primitive Type) 변수의 초기화
    Engine e = new Engine(); //참조형(reference Type) 변수의 초기화
}
```
2. 초기화 블럭(복잡한 초기화를 할때 사용한다)
- 인스턴스 초기화 블럭 : {} < 이건 잘 안씀
- 클래스 초기화 블럭 : static{}
```java
// cv복잡 초기화
Class staticBlock {
    static int[] arr = new int[10]; //명시적 초기화

    static { // 클래스 초기화 블럭 - 배열 arr을 난수로 채운다
        for(int i=0; i<arr.length; i++) {
            arr[i] = (int)(math.random()*10)+1;
        }
    }
}
```
3. 생성자
```java
// iv복잡 초기화
Car(String color, String gearType, int door) { 

this.color = color;
this.gearType = gearType;
this.door = door
}
```
1. 클래스 변수 초기화 시점
    - 클래스가 처음 메모리에 올라갈 때 단 한번
2. 인스턴스 변수 초기화 시점
    - 인스턴스가 생성될 때 마다
---
---
