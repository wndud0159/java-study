# 애너테이션
- 주석처럼 프로그래밍 언어에 영향을 미치지 않으며, 유용한 정보를 제공
- 애너테이션을 직접 만들어 사용할 수 있다
- 애너테이션의 메소드는 추상메서드이며, 애너테이션을 적용할 때 지정(순서x)
```java
@interface 애너테이션이름 {
    타입 요소이름();
}
```
---
---
## 애너테이션의 요소
- 적용시 값을 지정하지 않으면, 사용될 수 있는 기본값 지정 가능(null제외)
- 요소가 하나이고 이름이 value일 때는요소이름 생략 가능
- 요소의 타입이 배열인 경우, 괄호{}를 사용해야 한다.
```java
@interface TestInfo {
    int count() default 1; // 기본값을 1로 지정
}

@interface TestInfo {
    String value();
}
@TestInfo("passed") // TestInfo(value="passed")와 동일

@interface TestInfo {
    String[] testTools();
}
@TestInfo(testTools = {"dd","ss","aa"})
@TestInfo(testTools = "dd") // 하나일 땐 괄호 생략
@TestInfo(testTools = {}) // 값이 없을 때 {}가 반드시 필요
```
---
---
## 모든 애너테이션의 조상
- Annotation은 모든 애너테이션의 조상이지만 상속은 불가
- 사실 Annotation은 인터페이스이다.
---
---
## 마커 애너테이션
- 요소가 하나도 정의되지 않은 애너테이션
- 이 메서드가 어떤걸 하는 대상인지를 프로그램에 알리는 용도?...
---
---
## 애너테이션의 요소의 규칙
- 애너테이션의 요소를 선언할 때 아래의 규칙을 반드시 지켜야 한다
  - 요소의 타입은 기본형, String, enum, 애너테이션, Class만 허용됨
  - 괄호()안에 매개변수 선언불가
  - 예외 선언 불가
  - 요소를 타입 매배변수(지네릭)로 정의할 수 없다
---
---
## @Override
- 오버라이딩을 올바르게 했는지 컴파일러가 체크하게 한다
- 오버라이딩할 때 메서드이름을 잘못적는 실수를 하는 경우가 많다.
- 오버라이딩할 때는 메서드 선언부 앞에 @Override를 붙이자
---
---
## @Diprecated
- 앞으로 사용하지 않을 것을 권장하는 필드나 메서드에 붙인다.
- 지우면 되지만 왜 가지고 있느냐 하위 호완성을 위해서
- @Deprecated가 붙은 대상이 사용된 코드를 컴파일하면 경고메세지가 나온다
---
---
## @FunctionallInterface
- 함수형 인터페이스에 붙이면, 컴파일러가 올바르게 작성했는지 체크
- 함수형 인터페이스에는 하나의 추상메서드만 가져야 한다는 제약이 있음
---
---
## @SuppressWarnings
- 컴파일러의 경고메세지가 나타나지 않게 억제한다.
- 괄호()안에 억제하고자하는 경고의 종류를 문자열로 지정
- -Xlint옵션으로 컴파일하면, 경고메세지를 확인할 수 있다
  - 괄호[]안이 경고의 종류
---
---
## 메타 애너테이션
- 메타 애너테이션은 애너테이션을 위한 애너테이션
- 메타 애너테이션은 java.lang.annotation패키지에 포함
- Target
  - 애너테이션이 적용가능한 대상을 지정하는데 사용한다.
- Documented
  - 애너테이션 정보가 javadoc으로 작성된 문서에 포함되게 한다.
- Ingerited
  - 애너테이션이 자손 클래스에 상속되도록 한다
- Retention
  - 애너테이션이 유지되는 범위를 지정하는데 사용한다.
- Repeatable
  - 애너테이션을 반복해서 적용할 수 있게 한다.(jdk1.8)